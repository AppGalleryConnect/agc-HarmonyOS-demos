"use strict";
/**
 * Copyright (c) Huawei Technologies Co., Ltd. 2020-2020. All rights reserved.
 */
var __values = (this && this.__values) || function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Utils = void 0;
var FieldType_1 = require("./FieldType");
var AGConnectCloudDBException_1 = require("../exception/AGConnectCloudDBException");
var CloudDBErrorCode_1 = require("../exception/CloudDBErrorCode");
var DataModelHelper_1 = require("./DataModelHelper");
var uuid_1 = require("uuid");
/**
 * the utils class.
 */
var Utils = /** @class */ (function () {
    function Utils() {
    }
    /**
     * This method is used to check whether the input value is Array.
     *
     * @param value the value that need to check.
     * @returns whether the input is a array.
     */
    Utils.isArray = function (value) {
        if (typeof Array.isArray === 'function') {
            return Array.isArray(value);
        }
        else {
            return Object.prototype.toString.call(value) === '[object Array]';
        }
    };
    /**
     * This method is used to check whether the input value is null or undefined.
     *
     * @param value the value that need to check.
     * @returns whether the input is a null or undefined.
     */
    Utils.isNullOrUndefined = function (value) {
        return value === undefined || value === null;
    };
    /**
     * This method is used to check whether the input value is type of object.
     *
     * @param value the value that need to check.
     * @returns whether the input is type of object.
     */
    Utils.isNotNullObject = function (value) {
        return value !== null ? typeof value === 'object' : false;
    };
    /**
     * This method is used to serialize objects.
     *
     * @param objects a list of objects.
     * @returns a list of serialized objects.
     */
    Utils.serializeObjects = function (objects) {
        var _this = this;
        var formatedData = [];
        objects.forEach(function (element) {
            var object = _this.serializeObject(element);
            formatedData.push(object);
        });
        return formatedData;
    };
    Utils.serializeDate = function (date) {
        if (!(date instanceof Date)) {
            return date;
        }
        return date.getTime();
    };
    /**
     * This method is used to deserialize objects.
     *
     * @param objects a list of objects.
     * @param fieldTypeMap a map of field name and filed type.
     * @param targetClass the class that json string deserializes to.
     * @returns a list of deserialized objects.
     */
    Utils.deserializeObjects = function (objects, fieldTypeMap, targetClass) {
        var formatedData = [];
        objects.forEach(function (element) {
            var e_1, _a;
            var object = new targetClass();
            try {
                for (var _b = __values(fieldTypeMap.keys()), _c = _b.next(); !_c.done; _c = _b.next()) {
                    var key = _c.value;
                    if (element[key] === undefined || object.getEncryptedFieldList().includes(key)) {
                        object[key] = undefined;
                        continue;
                    }
                    if (element[key] === null) {
                        object[key] = null;
                        continue;
                    }
                    var fieldType = fieldTypeMap.get(key);
                    if (fieldType === FieldType_1.FieldType.Date) {
                        object[key] = Utils.deserializeDate(element[key]);
                        continue;
                    }
                    if (Utils.isFieldTypeNumber(fieldType)) {
                        object[key] = Utils.deserializeNumber(element[key]);
                        continue;
                    }
                    if (fieldType === FieldType_1.FieldType.ByteArray) {
                        object[key] = Utils.base64ToArrayBuffer(element[key]);
                        continue;
                    }
                    object[key] = element[key];
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
                }
                finally { if (e_1) throw e_1.error; }
            }
            formatedData.push(object);
        });
        return formatedData;
    };
    Utils.arrayBufferToBase64 = function (arrayBuffer) {
        var buffer = Buffer.from(arrayBuffer);
        return buffer.toString('base64');
    };
    Utils.base64ToArrayBuffer = function (base64) {
        var myBuffer = Buffer.from(base64, 'base64');
        var int8View = new Uint8Array(myBuffer);
        return int8View.slice();
    };
    Utils.isFieldTypeNumber = function (fieldType) {
        if (!fieldType) {
            throw new AGConnectCloudDBException_1.AGConnectCloudDBException(CloudDBErrorCode_1.CloudDBErrorCode.PARAMETER_INVALID);
        }
        switch (fieldType) {
            case FieldType_1.FieldType.Byte:
            case FieldType_1.FieldType.Short:
            case FieldType_1.FieldType.Integer:
            case FieldType_1.FieldType.IntAutoIncrement:
            // remaining case FieldType.Long
            case FieldType_1.FieldType.Float:
            case FieldType_1.FieldType.Double:
                return true;
            default:
                return false;
        }
    };
    Utils.deserializeNumber = function (data) {
        if (typeof data === 'string') {
            return Number(data).valueOf();
        }
        return data;
    };
    Utils.deserializeDate = function (date) {
        if (!this.DATE_REG_EXP.test(date)) {
            console.warn('The date string from cloud is invalid: ', date);
            throw new AGConnectCloudDBException_1.AGConnectCloudDBException(CloudDBErrorCode_1.CloudDBErrorCode.DATE_STRING_INVALID);
        }
        var utcDateString = date.replace(' ', 'T').replace(' ', '.') + 'Z';
        return new Date(utcDateString);
    };
    /**
     * This method is used to serialize queryConditions.
     *
     * @param queryConditions the input query conditions.
     * @param fieldTypeMap a map of field name and filed type.
     * @returns the serialized queryConditions.
     */
    Utils.serializeQueryConditions = function (queryConditions, fieldTypeMap) {
        var _this = this;
        var formatedCondition = [];
        queryConditions.forEach(function (queryCondition) {
            var conditionCopy = {};
            Object.assign(conditionCopy, queryCondition);
            if (Utils.isPaginationType(queryCondition.conditionType)) {
                if (!Utils.isObjectValid(queryCondition.value)) {
                    console.warn(new AGConnectCloudDBException_1.AGConnectCloudDBException(CloudDBErrorCode_1.CloudDBErrorCode.OBJECT_IS_INVALID).message);
                    throw new AGConnectCloudDBException_1.AGConnectCloudDBException(CloudDBErrorCode_1.CloudDBErrorCode.OBJECT_IS_INVALID);
                }
                conditionCopy.value = _this.serializeObject(queryCondition.value);
                formatedCondition.push(conditionCopy);
                return;
            }
            if (fieldTypeMap.get(queryCondition.fieldName) === FieldType_1.FieldType.Date
                && queryCondition.conditionType === "In" /* IN */) {
                for (var i = 0; i < queryCondition.value.length; i++) {
                    conditionCopy.value[i] = Utils.serializeDate(queryCondition.value[i]);
                }
            }
            else {
                conditionCopy.value = Utils.serializeDate(queryCondition.value);
            }
            formatedCondition.push(conditionCopy);
        });
        return formatedCondition;
    };
    /**
     * This method is used to check whether the input fieldType is numeric type.
     *
     * @param fieldType the fieldType that needs to check.
     * @returns boolean value of the check result.
     */
    Utils.isNumericField = function (fieldType) {
        return fieldType === FieldType_1.FieldType.Double || fieldType === FieldType_1.FieldType.Byte || fieldType === FieldType_1.FieldType.Float
            || fieldType === FieldType_1.FieldType.Integer || fieldType === FieldType_1.FieldType.Long || fieldType === FieldType_1.FieldType.Short
            || fieldType === FieldType_1.FieldType.IntAutoIncrement || fieldType === FieldType_1.FieldType.LongAutoIncrement;
    };
    /**
     * This method is used to check whether the input class is valid.
     *
     * @param clazz the class that needs to check.
     * @throws throw an AGConnectCloudDBException if the class is invalid.
     */
    Utils.clazzCheck = function (clazz) {
        var obj = new clazz();
        if (!this.isObjectValid(obj)) {
            console.warn(new AGConnectCloudDBException_1.AGConnectCloudDBException(CloudDBErrorCode_1.CloudDBErrorCode.CLASS_INVALID).message);
            throw new AGConnectCloudDBException_1.AGConnectCloudDBException(CloudDBErrorCode_1.CloudDBErrorCode.CLASS_INVALID);
        }
    };
    /**
     * This method is used to check whether the input object is valid.
     *
     * @param object the object that needs to check.
     * @returns boolean value of the check result.
     */
    Utils.isObjectValid = function (object) {
        return (typeof object.getFieldTypeMap == 'function'
            && typeof object.getClassName == 'function'
            && typeof object.getPrimaryKeyList == 'function'
            && typeof object.getIndexList == 'function'
            && typeof object.getEncryptedFieldList == 'function');
    };
    Utils.serializeObject = function (element) {
        var e_2, _a;
        var object = {};
        var fieldTypeMap = element.getFieldTypeMap();
        var encryptedFieldList = element.getEncryptedFieldList();
        try {
            for (var _b = __values(Object.keys(element)), _c = _b.next(); !_c.done; _c = _b.next()) {
                var key = _c.value;
                if (element[key] === undefined || encryptedFieldList.includes(key)) {
                    continue;
                }
                // upsert or update can set null
                if (element[key] === null) {
                    object[key] = null;
                    continue;
                }
                var fieldType = fieldTypeMap.get(key);
                if (Utils.isNumericField(fieldType) && !isFinite(element[key])) {
                    console.warn(new AGConnectCloudDBException_1.AGConnectCloudDBException(CloudDBErrorCode_1.CloudDBErrorCode.NUMBER_IS_INVALID).message);
                    throw new AGConnectCloudDBException_1.AGConnectCloudDBException(CloudDBErrorCode_1.CloudDBErrorCode.NUMBER_IS_INVALID);
                }
                if (fieldTypeMap.get(key) === FieldType_1.FieldType.Date) {
                    object[key] = Utils.serializeDate(element[key]);
                    continue;
                }
                if (fieldType === FieldType_1.FieldType.ByteArray) {
                    object[key] = Utils.arrayBufferToBase64(element[key]);
                    continue;
                }
                object[key] = element[key];
            }
        }
        catch (e_2_1) { e_2 = { error: e_2_1 }; }
        finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            }
            finally { if (e_2) throw e_2.error; }
        }
        return object;
    };
    /**
     * This method is used to check whether the input conditionType is aggregate type.
     *
     * @param conditionType the conditionType that needs to check.
     * @returns boolean value of the check result.
     */
    Utils.isAggregateType = function (conditionType) {
        var array = ["Average" /* AVG */, "Count" /* COUNT */, "Max" /* MAX */, "Min" /* MIN */,
            "Sum" /* SUM */];
        return array.includes(conditionType);
    };
    /**
     * This method is used to check whether the input conditionType is pagination type.
     *
     * @param conditionType the conditionType that needs to check.
     * @returns boolean value of the check result.
     */
    Utils.isPaginationType = function (conditionType) {
        var array = ["StartAt" /* START_AT */, "StartAfter" /* START_AFTER */, "EndAt" /* END_AT */,
            "EndBefore" /* END_BEFORE */];
        return array.includes(conditionType);
    };
    /**
     * This method is used to check whether the object list contains different schema
     * and whether the data size is too large.
     *
     * @param objectList the input objectList.
     */
    Utils.checkSchemaAndDataSize = function (objectList) {
        var _this = this;
        var className;
        objectList.forEach(function (element) {
            if (!Utils.isObjectValid(element)) {
                console.warn(new AGConnectCloudDBException_1.AGConnectCloudDBException(CloudDBErrorCode_1.CloudDBErrorCode.OBJECT_IS_INVALID).message);
                throw new AGConnectCloudDBException_1.AGConnectCloudDBException(CloudDBErrorCode_1.CloudDBErrorCode.OBJECT_IS_INVALID);
            }
            if (!DataModelHelper_1.DataModelHelper.validate(element)) {
                console.warn(new AGConnectCloudDBException_1.AGConnectCloudDBException(CloudDBErrorCode_1.CloudDBErrorCode.ERROR_CODE_DATA_INVALID).message);
                throw new AGConnectCloudDBException_1.AGConnectCloudDBException(CloudDBErrorCode_1.CloudDBErrorCode.ERROR_CODE_DATA_INVALID);
            }
            if (className == null) {
                className = element.getClassName();
            }
            if (className != element.getClassName()) {
                console.warn(new AGConnectCloudDBException_1.AGConnectCloudDBException(CloudDBErrorCode_1.CloudDBErrorCode.ONLY_SUPPORT_ONE_SCHEMA).message);
                throw new AGConnectCloudDBException_1.AGConnectCloudDBException(CloudDBErrorCode_1.CloudDBErrorCode.ONLY_SUPPORT_ONE_SCHEMA);
            }
            _this.checkIllegalCharacter(element);
            var objectListSize = DataModelHelper_1.DataModelHelper.calculateObject(element);
            if (objectListSize > Utils.MAX_OBJECT_CAPACITY) {
                console.warn(new AGConnectCloudDBException_1.AGConnectCloudDBException(CloudDBErrorCode_1.CloudDBErrorCode.DATA_SIZE_IS_OVERFLOW).message);
                throw new AGConnectCloudDBException_1.AGConnectCloudDBException(CloudDBErrorCode_1.CloudDBErrorCode.DATA_SIZE_IS_OVERFLOW);
            }
        });
    };
    /**
     * This method is used to check whether the object contains illegal character.
     *
     * @param object the object needs to be checked.
     */
    Utils.checkIllegalCharacter = function (object) {
        var e_3, _a;
        var fieldTypeMap = object.getFieldTypeMap();
        try {
            for (var _b = __values(fieldTypeMap.keys()), _c = _b.next(); !_c.done; _c = _b.next()) {
                var key = _c.value;
                if (fieldTypeMap.get(key) == 'String' || fieldTypeMap.get(key) == 'Text') {
                    var value = object[key];
                    if (value == null) {
                        continue;
                    }
                    if (value.indexOf('\0') !== -1) {
                        console.warn(new AGConnectCloudDBException_1.AGConnectCloudDBException(CloudDBErrorCode_1.CloudDBErrorCode.INPUT_CONTAIN_ILLEGAL_CHARACTER).message);
                        throw new AGConnectCloudDBException_1.AGConnectCloudDBException(CloudDBErrorCode_1.CloudDBErrorCode.INPUT_CONTAIN_ILLEGAL_CHARACTER);
                    }
                }
            }
        }
        catch (e_3_1) { e_3 = { error: e_3_1 }; }
        finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            }
            finally { if (e_3) throw e_3.error; }
        }
    };
    Utils.getRequestId = function () {
        var uuid = uuid_1.v4();
        var re = /-/gi;
        return uuid.replace(re, '');
    };
    Utils.primaryKeyCompareTo = function (object1, object2, filedType) {
        switch (filedType) {
            case FieldType_1.FieldType.Byte:
            case FieldType_1.FieldType.Short:
            case FieldType_1.FieldType.Integer:
            case FieldType_1.FieldType.IntAutoIncrement:
                return object1 - object2;
            case FieldType_1.FieldType.String:
                return object1.localeCompare(object2);
            case FieldType_1.FieldType.Long:
            case FieldType_1.FieldType.LongAutoIncrement:
                return this.longCompareTo(object1, object2);
        }
    };
    Utils.longCompareTo = function (object1, object2) {
        if (!Utils.NUMBER_REG_EXP.test(object1) || !Utils.NUMBER_REG_EXP.test(object2)) {
            throw new AGConnectCloudDBException_1.AGConnectCloudDBException(CloudDBErrorCode_1.CloudDBErrorCode.ERROR_CODE_DATA_INVALID);
        }
        if (object1.charAt(0) === '-' && object2.charAt(0) !== '-') {
            return -1;
        }
        if (object1.charAt(0) !== '-' && object2.charAt(0) === '-') {
            return 1;
        }
        var defaultValue = object1.charAt(0) === '-' ? -1 : 1;
        if (object1.length > object2.length) {
            return defaultValue;
        }
        if (object1.length < object2.length) {
            return -defaultValue;
        }
        for (var i = 0; i < object1.length; i++) {
            var res = object1.charAt(i).localeCompare(object2.charAt(i));
            if (res !== 0) {
                return defaultValue * res;
            }
        }
        return 0;
    };
    Utils.serializeMapObject = function (object, map) {
        var e_4, _a;
        var newObject = Object.create(object);
        try {
            for (var map_1 = __values(map), map_1_1 = map_1.next(); !map_1_1.done; map_1_1 = map_1.next()) {
                var _b = __read(map_1_1.value, 2), key = _b[0], value = _b[1];
                newObject[key] = value;
            }
        }
        catch (e_4_1) { e_4 = { error: e_4_1 }; }
        finally {
            try {
                if (map_1_1 && !map_1_1.done && (_a = map_1.return)) _a.call(map_1);
            }
            finally { if (e_4) throw e_4.error; }
        }
        Utils.checkSchemaAndDataSize([newObject]);
        return Utils.serializeObject(newObject);
    };
    Utils.deepCopy = function (objectList) {
        var e_5, _a;
        var list = [];
        try {
            for (var objectList_1 = __values(objectList), objectList_1_1 = objectList_1.next(); !objectList_1_1.done; objectList_1_1 = objectList_1.next()) {
                var objectItem = objectList_1_1.value;
                if (typeof objectItem !== 'object') {
                    list.push(objectItem);
                    continue;
                }
                if (objectItem.constructor === Date) {
                    list.push(new Date(objectItem));
                    continue;
                }
                if (objectItem.constructor === RegExp) {
                    list.push(new RegExp(objectItem));
                    continue;
                }
                if (objectItem.clone) {
                    list.push(objectItem.clone());
                    continue;
                }
                var newObj = new objectItem.constructor();
                for (var key in objectItem) {
                    if (Object.hasOwnProperty.call(objectItem, key)) {
                        var val = objectItem[key];
                        newObj[key] = val;
                    }
                }
                list.push(newObj);
            }
        }
        catch (e_5_1) { e_5 = { error: e_5_1 }; }
        finally {
            try {
                if (objectList_1_1 && !objectList_1_1.done && (_a = objectList_1.return)) _a.call(objectList_1);
            }
            finally { if (e_5) throw e_5.error; }
        }
        return list;
    };
    Utils.DATE_REG_EXP = /^[1-9]\d{3}-\d{2}-\d{2}\s\d{2}:\d{2}:\d{2}\s\d{3}/;
    Utils.NUMBER_REG_EXP = /^(-)?(0|[1-9][0-9]*)$/;
    Utils.MAX_OBJECT_CAPACITY = 2 * 1024 * 1024;
    return Utils;
}());
exports.Utils = Utils;
